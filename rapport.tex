\documentclass[10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\title{Devoir 1 
 Concepts des langages de programmation }
 

\author{Shayan Nicolas Hollet (20146766)\\
Ahmed Mhedhbi (20237399)}
\date{6 novembre 2023}


\begin{document}
\maketitle

\section*{Résumé}
Implantation d'une sorte de Lisp (Slip) en Haskell. Nous allons décrire notre expérience avec les problèmes que nous avons rencontré, les surprises, les choix que nous avons dû faire et les hypothèses qu'on a accepté/refusé pour chaque fonction.

\section*{1 Compréhension du TP}
En nous appuyant sur la structure et les directives fournies dans le document du TP, nous avons entrepris de compléter les composantes essentielles d'un interpréteur Slip implémenté en Haskell. Ce processus comprenait la finalisation des fonctions s2l, hinsert, et eval pour concrétiser le traitement des expressions Slip. La fonction s2l a été affinée pour transformer de manière cohérente les S-expressions en expressions lambda (Lexp), en veillant à la préservation des priorités opératoires dans la syntaxe de Slip. Cet effort a exigé une compréhension approfondie de la sémantique dynamique de Slip, où les types sont résolus à l'exécution, et des règles d'évaluation propres au lambda-calcul, notamment l'appel par valeur. Concernant hinsert, notre intervention a permis de corriger et d'assurer la mise à jour effective des valeurs dans le tas, qui représente la mémoire de notre langage. L'implémentation initiale de hinsert ne gérait pas correctement le remplacement des valeurs des ref-cell existantes ; notre contribution a été de résoudre ce problème, en garantissant que les nouvelles valeurs soient correctement assignées. La fonction eval a été particulièrement délicate, notamment pour la gestion de l'évaluation curried avec Lfuncall. Nous avons dû mettre en place un mécanisme d'accumulation sophistiqué pour gérer les applications successives de fonctions, en respectant l'évaluation paresseuse de Haskell. Cela a nécessité une réflexion approfondie sur le concept d'évaluation curried et sur la manière dont Haskell traite les fermetures fonctionnelles. En outre, l'évaluation des expressions Lrec a présenté des défis en raison de la nécessité de traiter des déclarations de fonctions mutuellement récursives. Ce problème a été abordé en élaborant un environnement étendu qui permet de lier de manière paresseuse les fonctions à leur environnement avant leur évaluation complète, permettant ainsi la résolution des références circulaires. À travers ce travail, nous avons non seulement consolidé notre compréhension de la programmation fonctionnelle et des langages de type Lisp mais également contribué à la robustesse de l'interpréteur Slip. Notre démarche a été guidée par une analyse minutieuse du code fourni, une attention particulière aux détails de l'implémentation et une application rigoureuse des concepts théoriques relatifs aux langages de compilation et d'interprétation.

\section*{2 Fonctions}
\subsection*{2.1 s2l}
Dans notre tâche de compléter la fonction s2l pour la conversion de S-expressions en expressions lambda (Lexp), nous avons été confrontés à des défis notables et avons pris des décisions clés pour assurer la fidélité sémantique à la syntaxe Slip. Nous avons dû accorder une attention particulière à l'ordre des opérations, spécifiquement pour Lfuncall, qui doit être évalué en dernier en tant qu'opération générale, pour respecter la priorité des opérations dans Slip. Cette contrainte a nécessité un traitement précautionneux des expressions pour garantir que les opérations arithmétiques et booléennes soient exécutées avant les appels de fonctions. La transformation de letrec a présenté une complexité, car elle devait gérer un cas de binding unique pour créer la liste Lexp des variables. Nous avons dû naviguer entre le respect des règles de scope de Slip et les capacités de Haskell pour représenter les fonctions mutuellement récursives. Un problème inattendu est survenu avec le symbole lambda ($\lambda$) qui n'était pas reconnu correctement par l'analyseur syntaxique. Nous avons dû attendre une mise à jour de l'analyseur pour que notre fonction s2l puisse correctement interpréter et transformer ce symbole en Labs. L'implémentation de l'évaluation curried s'est avérée être un défi en raison de la nature inhabituelle des expressions curried dans Slip. Nous avons dû adapter notre compréhension du curried dans un contexte fonctionnel pur pour le refléter correctement dans notre interpréteur. Lorsque letrec était typé en utilisant Lfuncall et non en Lrec, nous avons rencontré des problèmes de représentation qui nous ont obligés à remanier la structure Lexp. Nous avons opté pour une représentation qui sépare clairement les déclarations de fonction des appels de fonction, afin de simplifier la résolution et l'évaluation des bindings récursifs. Notre expérience avec s2l nous a amené à approfondir notre compréhension des constructions fonctionnelles et à prendre des décisions éclairées pour assurer la précision de l'interprétation des expressions Slip. Nous avons choisi d'adopter des hypothèses qui alignent notre implémentation avec les comportements attendus dans Slip, tout en rejetant celles qui auraient introduit des incongruités ou des complications inutiles.

\subsection*{2.2 hinsert}
La fonction hinsert que nous avons développée pour notre interpréteur Lisp Slip gère l'insertion de valeurs dans un tas binaire, représenté par une structure d'arbre de type trie. Cette implémentation a été conçue pour permettre l'allocation et la mise à jour de ref-cells, qui sont des cellules mémoire pouvant être modifiées pendant l'exécution du programme. La structure de l'environnement était un arbre trie pour sa capacité à représenter efficacement un espace d'adresses dispersé. Chaque nœud de l'arbre correspond à un bit dans la représentation binaire de l'adresse de la ref-cell. Les adresses paires prennent le chemin gauche de l'arbre, tandis que les impaires prennent le chemin droit. L'insertion est effectuée en divisant la valeur de l'adresse par deux et en choisissant le sous-arbre gauche pour les adresses paires et le sous-arbre droit pour les adresses impaires. Cette méthode récursive se poursuit jusqu'à ce que l'adresse soit réduite à zéro, indiquant que la position correcte pour l'insertion a été trouvée. Cela simplifie la recherche et l'insertion en réduisant le problème à un ensemble de décisions binaires. Par contre, lorsque nous rencontrons une ref-cell existante, la nouvelle valeur doit remplacer l'ancienne. Notre fonction hinsert est conçue pour mettre à jour la valeur existante sans créer de nouvelle ref-cell, ce qui est essentiel pour gérer correctement les mises à jour en place et pour éviter les fuites de mémoire. En conformité avec les principes de la programmation fonctionnelle et Haskell, hinsert est écrite pour être une fonction pure. Ainsi, au lieu de modifier l'arbre en place, elle renvoie une nouvelle version de l'arbre avec la valeur mise à jour. Cette approche préserve l'immutabilité et garantit que les fonctions restent pures, facilitant le raisonnement sur le code et évitant les effets de bord non désirés. Aussi, nous avons dû gérer des cas d'erreurs où des adresses négatives pouvaient être fournies, ce qui n'est pas valide dans notre contexte. Des vérifications ont été ajoutées pour assurer que de telles adresses déclenchent une erreur explicite, maintenant ainsi l'intégrité de notre tas. Un autre défi était de s'assurer que la mise à jour des valeurs se fasse en place. Cela a nécessité une compréhension claire de la mutabilité simulée dans un contexte immuable. Nous avons dû veiller à ce que notre fonction hinsert remplace effectivement les valeurs existantes sans altérer les autres parties de l'arbre. 

En résumé, la fonction hinsert a été conçue avec un souci d'efficacité et de cohérence avec les paradigmes fonctionnels. Les choix que nous avons faits reflètent notre engagement à fournir une solution à la fois élégante et conforme aux attentes théoriques de la gestion de la mémoire dans un interpréteur Slip.

\subsection*{2.3 eval}

La fonction eval a constitué le coeur de l'interprétation des expressions Lexp au sein de notre interpréteur Slip, où nous avons appliqué la sémantique opérationnelle du langage cible. La conception de eval a exigé une compréhension approfondie des environnements d'exécution, des états de mémoire et de la nature paresseuse de l'évaluation fonctionnelle. Initialement, l'évaluation des appels de fonctions a révélé une difficulté à implémenter le currying de manière intuitive. L'introduction d'un accumulateur de fonctions s'est avérée nécessaire pour maintenir l'état intermédiaire des applications partielles de fonctions. Cela a permis d'évaluer correctement des expressions curried complexes, où chaque fonction partielle est appliquée successivement à son argument. Ensuite,la gestion des fonctions mutuellement récursives dans Lrec a présenté une difficulté majeure. Notre première approche utilisant un nouvel environnement et des fermetures s'est avérée insuffisante. Nous avons alors exploré l'évaluation paresseuse, sur suggestion du forum du cours, pour différer l'évaluation des expressions jusqu'à ce qu'elles soient nécessaires. Cette stratégie a été essentielle pour traiter les déclarations récursives. Finalement, l'introduction de l'évaluation paresseuse a résolu les problèmes de récursivité, mais a introduit un nouvel obstacle : l'initialisation correcte des variables d'environnement. Pour remédier à cela, nous avons consulté des ressources en ligne et avons opté pour l'utilisation de Vthunk dans notre type Value. Cette enveloppe paresseuse a permis de lier les variables à des expressions non évaluées, qui sont ensuite résolues lors de l'accès. Cela a été particulièrement efficace pour traiter des cas comme des chaînes de références mutables interdépendantes.

La mise en place de l'évaluation paresseuse a été un tournant dans notre projet, nous permettant d'atteindre une fidélité sémantique avec Slip tout en naviguant dans les contraintes de l'immutabilité de Haskell. Le passage à Vthunk a été une décision mûrement réfléchie, prise pour répondre à des cas de test complexes où l'évaluation immédiate échouait.

Le développement de la fonction eval a été un processus itératif et instructif, illustrant l'importance de la correspondance entre la théorie et la pratique dans la conception des langages. Chaque étape a été soigneusement documentée et justifiée pour assurer la transparence de notre démarche et la justesse de notre implémentation. Ce processus a non seulement enrichi notre compréhension des interpréteurs fonctionnels mais a également mis en évidence la polyvalence de Haskell pour exprimer des concepts de langages de programmation complexes de manière concise et puissante.

\section*{3 Tests}

Nous avons soigneusement sélectionné des tests pour valider de manière exhaustive les capacités et la robustesse de notre interpréteur Slip. Chaque test est conçu pour vérifier un aspect spécifique de la sémantique opérationnelle et de l'intégrité de notre implémentation. Les expressions telles que $2$, $+$ et $(+$ $2$ $4)$ servent à vérifier les fonctionnalités élémentaires de notre évaluateur, y compris la reconnaissance des littéraux, la résolution des symboles, et l'évaluation des opérations arithmétiques simples. En utilisant des expressions lambda comme $((\lambda$  $x$  $x)$ $2)$ et $(((\lambda$ $x$ $(\lambda$ $y$ $(*$ $x$ $y)))$ $3)$ $5)$, nous testons la capacité de notre interpréteur à gérer les fermetures et les applications de fonctions avec currying. Les tests avec let et if, tels que $(let$ $true$ $false$ $(if$ $true$ $1$ $2))$, sont utilisés pour confirmer que les structures de contrôle fonctionnent comme prévu et que l'ordre d'évaluation est conforme à la sémantique attendue de Slip. Les tests impliquant ref!, set! et get! nous permettent de vérifier la gestion correcte des références mutables et de s'assurer que les mises à jour de l'état affectent les valeurs comme attendu. À travers des exemples plus complexes comme la récursivité avec letrec, nous examinons la capacité de notre interpréteur à gérer des fonctions récursives et à maintenir la portée lexicale, des aspects critiques de tout langage fonctionnel. Des tests tels que $(letrec$ $((odd$ $...))$ $(odd$ $7))$ et $(letrec$ $((fac$ $...))$ $(fac$ $5))$ sont essentiels pour valider l'évaluation paresseuse et la résolution des fonctions mutuellement récursives, garantissant que les dépendances circulaires sont résolues correctement. Des tests utilisant des fermetures imbriquées et des opérations en chaîne, comme $((((\lambda$ $x$ $(\lambda$ $y$ $(\lambda$ $z$ $(*$ $y$ $z))))$ $3)$ $2)$ $4)$, sont cruciaux pour vérifier l'intégrité des environnements imbriqués et l'ordre correct des opérations.Par contre, lors de nos tests sur des fonctions récursives complexes avec letrec, en particulier pour la fonction fib définissant la suite de Fibonacci, nous avons rencontré un cas où notre interpréteur n'a pas réussi à produire le résultat attendu : $(letrec$ $((fib$ $(\lambda$ $n$ $(if$ $(<$ $n$ $2)$ $n$ $(+$ $(fib$ $(-$ $n$ $1))$ $(fib$ $(-$ $n$ $2)))))))$ $(fib$ $5))$.Plutôt que de renvoyer le cinquième terme de la suite de Fibonacci, notre interpréteur est entré dans une boucle infinie pendant l'exécution de ce test.Voici nos hypothèses: Soit la cause de la boucle infinie de laa fonction fib requiert l'évaluation des deux appels récursifs $fib$ $(-$ $n$ $1)$ et $fib$ $(-$ $n$ $2)$ pour tout n >= 2. Notre implémentation actuelle de l'évaluation paresseuse dans letrec n'a pas réussi à capturer l'environnement d'évaluation de manière à ce que chaque appel récursif puisse bénéficier des résultats intermédiaires des appels précédents.Lorsque fib est invoquée avec un argument supérieur à 1, elle génère deux nouveaux appels à fib sans partager l'état entre eux. Cela conduit à une expansion exponentielle des appels récursifs, car chaque appel génère à son tour deux autres appels, et ainsi de suite, sans jamais réutiliser les calculs déjà effectués. Soit dans une implémentation fonctionnelle pure, comme celle de Haskell, nous sommes limités par la manière dont les fermetures capturent l'environnement lorsqu'elles sont créées. Pour une fonction récursive comme fib, cela signifie que chaque appel récursif doit réévaluer toute l'expansion de fib depuis le début, car il ne "se souvient" pas des calculs précédents.L'implémentation correcte de telles fonctions récursives nécessiterait une forme de mémoïsation ou de partage d'état entre les appels récursifs, ce qui peut être difficile à réaliser dans un cadre strictement paresseux et fonctionnel sans effet de bord. En résumé, les tests ont été rigoureusement choisis pour couvrir un large spectre de cas d'utilisation et pour garantir que chaque composant de notre interpréteur fonctionne comme prévu. Ils mettent en évidence non seulement la conformité aux spécifications de Slip mais aussi la précision de notre implémentation des concepts de programmation fonctionnelle. Or, le défi de gérer efficacement la récursivité profonde dans notre interpréteur Slip demeure un point d'étude actif pour nous, nécessitant une réflexion supplémentaire et potentiellement des innovations en termes de conception d'interpréteurs fonctionnels.Si non, les tests constituent un cadre fiable pour démontrer la validité de notre interpréteur et pour identifier les domaines nécessitant des ajustements ou des améliorations supplémentaires.

\end{document}
